import Ably
@testable import AblyChat
import Testing

@MainActor
struct DefaultConnectionTests {
    // @spec CHA-CS2a
    // @spec CHA-CS2b
    // @spec CHA-CS3
    @Test
    func chatClientMustExposeItsCurrentStatus() async throws {
        // Given: An instance of DefaultChatClient
        let options = ARTClientOptions(key: "fake:key")
        options.autoConnect = false
        let realtime = ARTRealtime(options: options)
        let client = DefaultChatClient(realtime: realtime, clientOptions: nil)

        // When: the connection status object is constructed
        let status = client.connection.status
        let error = client.connection.error

        #expect(status == .initialized)
        #expect(error == nil)
    }

    // @spec CHA-CS4a
    // @spec CHA-CS4b
    // @spec CHA-CS4c
    // @spec CHA-CS4d
    @Test
    func chatClientMustAllowItsConnectionStatusToBeObserved() async throws {
        // Given: An instance of DefaultChatClient and a connection error
        let connection = MockSuppliedRealtime.Connection(state: .connecting)
        let suppliedRealtime = MockSuppliedRealtime(createWrapperSDKProxyReturnValue: .init(connection: connection))
        let mockTimerManager = MockTimerManager()
        let client = DefaultChatClient(realtime: suppliedRealtime, clientOptions: nil, internalRealtimeClientFactory: DefaultInternalRealtimeClientFactory(), timerManager: mockTimerManager)
        let connectionError = ARTErrorInfo.createUnknownError()

        // When
        // (CHA-CS4d) Clients must be able to register a listener for connection status events and receive such events.
        client.connection.onStatusChange { statusChange in
            // Then
            // (CHA-CS4a) Connection status update events must contain the newly entered connection status.
            // (CHA-CS4b) Connection status update events must contain the previous connection status.
            // (CHA-CS4c) Connection status update events must contain the connection error (if any) that pertains to the newly entered connection status.
            #expect(statusChange.current == .disconnected)
            #expect(statusChange.previous == .connecting)
            #expect(statusChange.error == connectionError)
        }

        connection.emit(.disconnected, event: .disconnected, error: connectionError)
    }

    // @specUntested CHA-CS4f - We don't have method for unsubscribing all subscriptions at once in ``Connection`` protocol. Each subscription handle only unsubscribe its own listener (CHA-CS4e).

    // @spec CHA-CS5a1
    // @spec CHA-CS5a4
    // @spec CHA-CS4e
    @Test
    func whenConnectionGoesFromConnectedToDisconnectedTransientDisconnectTimerStarts() async throws {
        // Given:
        // An instance of DefaultChatClient, connected realtime connection and default chat connection
        let connection = MockSuppliedRealtime.Connection(state: .connected)
        let suppliedRealtime = MockSuppliedRealtime(createWrapperSDKProxyReturnValue: .init(connection: connection))
        let mockTimerManager = MockTimerManager()
        let client = DefaultChatClient(realtime: suppliedRealtime, clientOptions: nil, internalRealtimeClientFactory: DefaultInternalRealtimeClientFactory(), timerManager: mockTimerManager)
        let defaultConnection = try #require(client.connection as? DefaultConnection)

        // Status subscription
        var statusChanges = [ConnectionStatusChange]()
        let subscriptionHandle = defaultConnection.onStatusChange { statusChange in
            statusChanges.append(statusChange)
        }

        // When:

        // Realtime connection status transitions from CONNECTED to DISCONNECTED
        let connectionError = ARTErrorInfo.create(withCode: 0, message: "Connection error")
        connection.emit(.disconnected, event: .disconnected, error: connectionError)

        // Then:

        // Transient disconnect timer interval is 5 seconds
        #expect(mockTimerManager.callRecorder.waitUntil(
            hasMatching: "setTimer(interval:handler:)",
            arguments: ["interval": 5.0]
        )
        )

        // CHA-CS5a1: "the chat client connection status must not change"
        #expect(statusChanges.count == 0)

        // When
        mockTimerManager.expireTimer()

        // Then:
        // CHA-CS5a4: Status change was generated by `emit:` when transient timer has expired
        #expect(statusChanges[0].error == connectionError)

        // When
        subscriptionHandle.unsubscribe()
        connection.emit(.connected, event: .connected)

        // Then:
        // CHA-CS4e: no new events recorded after `unsubscribe` call
        #expect(statusChanges.count == 1)
    }

    // @spec CHA-CS5a2
    @Test
    func whenConnectionGoesFromDisconnectedToConnectingNoStatusChangeIsEmitted() async throws {
        // Given:
        // An instance of DefaultChatClient, connected realtime connection and default chat connection
        let realtimeConnection = MockSuppliedRealtime.Connection(state: .connected)
        let suppliedRealtime = MockSuppliedRealtime(createWrapperSDKProxyReturnValue: .init(connection: realtimeConnection))
        let mockTimerManager = MockTimerManager()
        let client = DefaultChatClient(realtime: suppliedRealtime, clientOptions: nil, internalRealtimeClientFactory: DefaultInternalRealtimeClientFactory(), timerManager: mockTimerManager)
        let defaultConnection = try #require(client.connection as? DefaultConnection)

        // Status subscription
        var statusChanges = [ConnectionStatusChange]()
        defaultConnection.onStatusChange { statusChange in
            statusChanges.append(statusChange)
        }

        // When:

        // Starting timer by going to DISCONNECTED
        realtimeConnection.emit(.disconnected, event: .disconnected)

        // Then:

        // Transient disconnect timer interval is 5 seconds
        #expect(mockTimerManager.callRecorder.waitUntil(
            hasMatching: "setTimer(interval:handler:)",
            arguments: ["interval": 5.0]
        )
        )

        // When:

        // Realtime connection status changes to CONNECTING
        realtimeConnection.emit(.connecting, event: .connecting)

        // Or DISCONNECTED
        realtimeConnection.emit(.disconnected, event: .disconnected)

        // Then:
        // CHA-CS5a2: the library must not emit a status change
        #expect(statusChanges.count == 0)
    }

    // @specOneOf(1/3) CHA-CS5a3 - Connection goes to CONNECTED
    @Test
    func whenConnectionGoesToConnectedStatusChangeShouldBeEmitted() async throws {
        // Given:
        // An instance of DefaultChatClient, connected realtime connection and default chat connection
        let realtimeConnection = MockSuppliedRealtime.Connection(state: .connected)
        let suppliedRealtime = MockSuppliedRealtime(createWrapperSDKProxyReturnValue: .init(connection: realtimeConnection))
        let mockTimerManager = MockTimerManager()
        let client = DefaultChatClient(realtime: suppliedRealtime, clientOptions: nil, internalRealtimeClientFactory: DefaultInternalRealtimeClientFactory(), timerManager: mockTimerManager)
        let defaultConnection = try #require(client.connection as? DefaultConnection)

        // Status subscription
        var statusChanges = [ConnectionStatusChange]()
        defaultConnection.onStatusChange { statusChange in
            statusChanges.append(statusChange)
        }

        // When:

        // Starting timer by going to DISCONNECTED
        realtimeConnection.emit(.disconnected, event: .disconnected)

        // Then:

        // Transient disconnect timer interval is 5 seconds
        #expect(mockTimerManager.callRecorder.waitUntil(
            hasMatching: "setTimer(interval:handler:)",
            arguments: ["interval": 5.0]
        )
        )

        // When:

        // And the realtime connection status changes to CONNECTED
        realtimeConnection.emit(.connected, event: .connected)

        // Then:
        #expect(mockTimerManager.callRecorder.waitUntil(
            hasMatching: "cancelTimer",
            arguments: [:]
        )
        )

        // Then:
        // CHA-CS5a3: The superseding status change shall be emitted
        #expect(statusChanges.count == 1)
        #expect(statusChanges[0].current == .connected)
    }

    // @specOneOf(2/3) CHA-CS5a3 - Connection goes to SUSPENDED
    @Test
    func whenConnectionGoesToSuspendedStatusChangeShouldBeEmitted() async throws {
        // Given:
        // An instance of DefaultChatClient, connected realtime connection and default chat connection
        let realtimeConnection = MockSuppliedRealtime.Connection(state: .connected)
        let suppliedRealtime = MockSuppliedRealtime(createWrapperSDKProxyReturnValue: .init(connection: realtimeConnection))
        let mockTimerManager = MockTimerManager()
        let client = DefaultChatClient(realtime: suppliedRealtime, clientOptions: nil, internalRealtimeClientFactory: DefaultInternalRealtimeClientFactory(), timerManager: mockTimerManager)
        let defaultConnection = try #require(client.connection as? DefaultConnection)

        // Status subscription
        var statusChanges = [ConnectionStatusChange]()
        defaultConnection.onStatusChange { statusChange in
            statusChanges.append(statusChange)
        }

        // When:

        // Starting timer by going to DISCONNECTED
        realtimeConnection.emit(.disconnected, event: .disconnected)

        // Then:

        // Transient disconnect timer interval is 5 seconds
        #expect(mockTimerManager.callRecorder.waitUntil(
            hasMatching: "setTimer(interval:handler:)",
            arguments: ["interval": 5.0]
        )
        )

        // When:

        // And the realtime connection status changes to SUSPENDED
        realtimeConnection.emit(.suspended, event: .suspended)

        // Then:
        #expect(mockTimerManager.callRecorder.waitUntil(
            hasMatching: "cancelTimer",
            arguments: [:]
        )
        )

        // Then:
        // CHA-CS5a3: The superseding status change shall be emitted
        #expect(statusChanges.count == 1)
        #expect(statusChanges[0].current == .suspended)
    }

    // @specOneOf(3/3) CHA-CS5a3 - Connection goes to FAILED
    @Test
    func whenConnectionGoesToFailedStatusChangeShouldBeEmitted() async throws {
        // Given:
        // An instance of DefaultChatClient, connected realtime connection and default chat connection
        let realtimeConnection = MockSuppliedRealtime.Connection(state: .connected)
        let suppliedRealtime = MockSuppliedRealtime(createWrapperSDKProxyReturnValue: .init(connection: realtimeConnection))
        let mockTimerManager = MockTimerManager()
        let client = DefaultChatClient(realtime: suppliedRealtime, clientOptions: nil, internalRealtimeClientFactory: DefaultInternalRealtimeClientFactory(), timerManager: mockTimerManager)
        let defaultConnection = try #require(client.connection as? DefaultConnection)

        // Status subscription
        var statusChanges = [ConnectionStatusChange]()
        defaultConnection.onStatusChange { statusChange in
            statusChanges.append(statusChange)
        }

        // When:

        // Starting timer by going to DISCONNECTED
        realtimeConnection.emit(.disconnected, event: .disconnected)

        // Then:

        // Transient disconnect timer interval is 5 seconds
        #expect(mockTimerManager.callRecorder.waitUntil(
            hasMatching: "setTimer(interval:handler:)",
            arguments: ["interval": 5.0]
        )
        )

        // When:

        // And the realtime connection status changes to FAILED
        realtimeConnection.emit(.failed, event: .failed)

        // Then:
        #expect(mockTimerManager.callRecorder.waitUntil(
            hasMatching: "cancelTimer",
            arguments: [:]
        )
        )

        // Then:
        // CHA-CS5a3: The superseding status change shall be emitted
        #expect(statusChanges.count == 1)
        #expect(statusChanges[0].current == .failed)
    }

    // @specUntested CHA-CS5b - The implementation of this part is not clear. I've commented extra call for emitting event because I think it's in the wrong place, see `callback(statusChange)` call with "this call shouldn't be here" comment in "DefaultConnection.swift".
}
